import os
import zipfile
from lxml import etree
from docx import Document
from docx.opc.constants import RELATIONSHIP_TYPE as RT

'''
create_base_docx() function:
Inputs:
- content (the content to be added to the document)
- header (the header for the document)
- filename (the name of the file to be created)
Outputs:
- A base Word document with content. Thinking it should be saved in a folder named after its tokenID to manage it.


inject_canary_xml() function:
Inputs:
- filename (the Directory path of the document to inject the canary token into)
- tracking_url (the URL of the image stored on the Kali box that will be used for tracking when the document is opened)
- rel_id (This will just be the tokenID pulled from tracking_url)
Outputs:
- The original document with the canary token injected and ready to be deployed.

Note: The logic for how we want to handle the document naming is incomplete but is easy to tweak once we decide how to structure the server.
'''

TRACKING_URL = "http://127.0.0.1:8080/images/testing.png" # this will be a url of a unique image to the word document. It will be created when a new token file is created in site.
# DOCX_FILENAME = "testing.docx" # hardcoded with the token.docx. The actual name the user wants will be used in the final
REL_ID = "rIdCanary" # this is whatever the token id is. Can be taken from the image url above.

# Creating a Word Doc
def create_base_docx(content, header, filename):
    document = Document()

    document.add_heading(header, 0) #the heading will also be generated by Gemini
    document.add_paragraph(content) # This is where we will add the content generated by the GenAi Tool. Will have to do some parsing to build it out to look correct with headings and tables and other content in it.

    document.save(filename)
    return filename

# Inject XML to Create the Canary Token
def inject_canary_xml(filename, tracking_url, rel_id):
    temp_dir = "temp_unzip"
    
    try:
        # Unzip the .docx file. This is how we access the correct XML file to inject the image
        with zipfile.ZipFile(filename, 'r') as zip_ref:
            zip_ref.extractall(temp_dir)

        # The relationships file for the main document
        rels_path = os.path.join(temp_dir, 'word', '_rels', 'document.xml.rels')
        
        # Define the XML for the external link relationship
        # TargetMode="External" is critical to make it a remote link. AKA tell word to pull down the image from our webserver.
        RELATIONSHIP_XML = f"""
        <Relationship Id="{rel_id}" 
                      Type="{RT.IMAGE}" 
                      Target="{tracking_url}" 
                      TargetMode="External"/>
        """
        
#-------- The below code was made with the assistance of Gemini through a variety of prompts----------
        # Append the new relationship XML
        tree = etree.parse(rels_path)
        root = tree.getroot()
        root.append(etree.fromstring(RELATIONSHIP_XML.strip()))
        tree.write(rels_path, pretty_print=True, xml_declaration=True, encoding='utf-8')
        print(f"Tracking URL injected into '{rels_path}' with Id '{rel_id}'.")

        # Standard namespaces used in document.xml (MUST be defined for lxml)
        NAMESPACES = {
            'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
            'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
            'v': 'urn:schemas-microsoft-com:vml',
            'o': 'urn:schemas-microsoft-com:office:office',
            # Note: These are the minimum needed for the VML structure
        }

        document_xml_path = os.path.join(temp_dir, 'word', 'document.xml')

        # Parse the document XML tree
        tree = etree.parse(document_xml_path)
        root = tree.getroot()
        body = root.find('w:body', NAMESPACES)

        if body is not None:
            p_tag = etree.Element(etree.QName(NAMESPACES['w'], 'p'))
            r_tag = etree.SubElement(p_tag, etree.QName(NAMESPACES['w'], 'r'))
            pict_tag = etree.SubElement(r_tag, etree.QName(NAMESPACES['w'], 'pict'))
            shape_tag = etree.SubElement(pict_tag, etree.QName(NAMESPACES['v'], 'shape'), 
                                            id="_x0000_i1025", 
                                            type="#_x0000_t75", 
                                            style="width:1pt;height:1pt")

            # CRITICAL: This links the image to the external relationship (r:id="{rel_id}")
            etree.SubElement(shape_tag, etree.QName(NAMESPACES['v'], 'imagedata'), 
                                {etree.QName(NAMESPACES['r'], 'id'): rel_id, 
                                etree.QName(NAMESPACES['o'], 'title'): ""})
            
            body.insert(0, p_tag)
            
            # Write the modified XML back to the file
            tree.write(document_xml_path, pretty_print=True, xml_declaration=True, encoding='utf-8')
            print("Token injected into 'document.xml'.")

        else:
            raise Exception("Could not find the <body> element in document.xml.")
        
#------------ End AI Generation --------------

        # Create a new zip file with the modified contents
        new_zip_filename = filename.replace(".docx", "_canary.docx") #this is temporary. We will make what the user wants the document name to be.
        
        with zipfile.ZipFile(new_zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, _, files in os.walk(temp_dir):
                for file in files:
                    file_path = os.path.join(root, file)
                    # Create the relative path inside the zip file
                    arcname = os.path.relpath(file_path, temp_dir)
                    zipf.write(file_path, arcname)
        
        # Rename the new file to the desired output filename
        if os.path.exists(filename):
            os.remove(filename) # Remove the original base file
        os.rename(new_zip_filename, filename)
        print(f"Document and saved as '{filename}'.")

    except Exception as e:
        print(f"Failed to Inject XML: {e}")
    
    finally:
        # Cleanup the temporary directory
        if os.path.exists(temp_dir):
            import shutil
            shutil.rmtree(temp_dir)
            print("Cleaned up temporary directory.")