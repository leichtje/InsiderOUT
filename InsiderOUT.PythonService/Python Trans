-- requirements.txt

fastapi
uvicorn[standard]
python-docx
lxml
pillow
fpdf
pikepdf
google-generativeai



--- main.py
from fastapi import FastAPI

app = FastAPI()

@app.get("/health")
def health():
    return {"status": "ok"}


--canary_creation.py

import os
import zipfile
from lxml import etree
from docx import Document
from docx.opc.constants import RELATIONSHIP_TYPE as RT

'''
create_base_docx() function:
Inputs:
- content (the content to be added to the document)
- header (the header for the document)
- filename (the name of the file to be created)
Outputs:
- A base Word document with content. Thinking it should be saved in a folder named after its tokenID to manage it.


inject_canary_xml() function:
Inputs:
- filename (the Directory path of the document to inject the canary token into)
- tracking_url (the URL of the image stored on the Kali box that will be used for tracking when the document is opened)
- rel_id (This will just be the tokenID pulled from tracking_url)
Outputs:
- The original document with the canary token injected and ready to be deployed.

Note: The logic for how we want to handle the document naming is incomplete but is easy to tweak once we decide how to structure the server.
'''

TRACKING_URL = "http://127.0.0.1:8080/images/testing.png" # this will be a url of a unique image to the word document. It will be created when a new token file is created in site.
# DOCX_FILENAME = "testing.docx" # hardcoded with the token.docx. The actual name the user wants will be used in the final
REL_ID = "rIdCanary" # this is whatever the token id is. Can be taken from the image url above.

# Creating a Word Doc
def create_base_docx(content, header, filename):
    document = Document()

    document.add_heading(header, 0) #the heading will also be generated by Gemini
    document.add_paragraph(content) # This is where we will add the content generated by the GenAi Tool. Will have to do some parsing to build it out to look correct with headings and tables and other content in it.

    document.save(filename)
    return filename

# Inject XML to Create the Canary Token
def inject_canary_xml(filename, tracking_url, rel_id):
    temp_dir = "temp_unzip"
    
    try:
        # Unzip the .docx file. This is how we access the correct XML file to inject the image
        with zipfile.ZipFile(filename, 'r') as zip_ref:
            zip_ref.extractall(temp_dir)

        # The relationships file for the main document
        rels_path = os.path.join(temp_dir, 'word', '_rels', 'document.xml.rels')
        
        # Define the XML for the external link relationship
        # TargetMode="External" is critical to make it a remote link. AKA tell word to pull down the image from our webserver.
        RELATIONSHIP_XML = f"""
        <Relationship Id="{rel_id}" 
                      Type="{RT.IMAGE}" 
                      Target="{tracking_url}" 
                      TargetMode="External"/>
        """
        
#-------- The below code was made with the assistance of Gemini through a variety of prompts----------
        # Append the new relationship XML
        tree = etree.parse(rels_path)
        root = tree.getroot()
        root.append(etree.fromstring(RELATIONSHIP_XML.strip()))
        tree.write(rels_path, pretty_print=True, xml_declaration=True, encoding='utf-8')
        print(f"Tracking URL injected into '{rels_path}' with Id '{rel_id}'.")

        # Standard namespaces used in document.xml (MUST be defined for lxml)
        NAMESPACES = {
            'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
            'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
            'v': 'urn:schemas-microsoft-com:vml',
            'o': 'urn:schemas-microsoft-com:office:office',
            # Note: These are the minimum needed for the VML structure
        }

        document_xml_path = os.path.join(temp_dir, 'word', 'document.xml')

        # Parse the document XML tree
        tree = etree.parse(document_xml_path)
        root = tree.getroot()
        body = root.find('w:body', NAMESPACES)

        if body is not None:
            p_tag = etree.Element(etree.QName(NAMESPACES['w'], 'p'))
            r_tag = etree.SubElement(p_tag, etree.QName(NAMESPACES['w'], 'r'))
            pict_tag = etree.SubElement(r_tag, etree.QName(NAMESPACES['w'], 'pict'))
            shape_tag = etree.SubElement(pict_tag, etree.QName(NAMESPACES['v'], 'shape'), 
                                            id="_x0000_i1025", 
                                            type="#_x0000_t75", 
                                            style="width:1pt;height:1pt")

            # CRITICAL: This links the image to the external relationship (r:id="{rel_id}")
            etree.SubElement(shape_tag, etree.QName(NAMESPACES['v'], 'imagedata'), 
                                {etree.QName(NAMESPACES['r'], 'id'): rel_id, 
                                etree.QName(NAMESPACES['o'], 'title'): ""})
            
            body.insert(0, p_tag)
            
            # Write the modified XML back to the file
            tree.write(document_xml_path, pretty_print=True, xml_declaration=True, encoding='utf-8')
            print("Token injected into 'document.xml'.")

        else:
            raise Exception("Could not find the <body> element in document.xml.")
        
#------------ End AI Generation --------------

        # Create a new zip file with the modified contents
        new_zip_filename = filename.replace(".docx", "_canary.docx") #this is temporary. We will make what the user wants the document name to be.
        
        with zipfile.ZipFile(new_zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, _, files in os.walk(temp_dir):
                for file in files:
                    file_path = os.path.join(root, file)
                    # Create the relative path inside the zip file
                    arcname = os.path.relpath(file_path, temp_dir)
                    zipf.write(file_path, arcname)
        
        # Rename the new file to the desired output filename
        if os.path.exists(filename):
            os.remove(filename) # Remove the original base file
        os.rename(new_zip_filename, filename)
        print(f"Document and saved as '{filename}'.")

    except Exception as e:
        print(f"Failed to Inject XML: {e}")
    
    finally:
        # Cleanup the temporary directory
        if os.path.exists(temp_dir):
            import shutil
            shutil.rmtree(temp_dir)
            print("Cleaned up temporary directory.")



-- gen.py

from google import genai
'''
Inputs:
- Short Description
- Target Audience
- Severity Level (Low, Medium, High)

Outputs:
- Content for the document
- A suitable header for the document
- A suitable file name for the document
- A targeted department for the document (This is important for comparing the user's dept with the documents)
'''
#--------Content Creation----------------
def generate_content():
        # TEMPORARY USER INPUT. FOR DEMO
        short_desc = input("Enter a short description of the document to be created (e.g., 'hr document containing payroll for finance team members'): ")
        target_audience = input("Enter the target audience for the document (e.g., 'finance team members'): ")
        severity_level = input("Enter the severity level for the document (Low, Medium, High): ")
        # The client gets the API key from the environment variable `GEMINI_API_KEY`.
        client = genai.Client()

        # Generate the content for the document based on the short description and target audience
        content_response = client.models.generate_content(
            model="gemini-2.5-flash",
            contents=f"You are an AI generating content for a {short_desc} for {target_audience}, make sure the file doesn't contain any logos, emojis, tables or header and make it strictly text based. Ensure the data is random but does not follow obvious patterns like sequential numbers or repeated values. The content should be realistic and relevant to the specified description and audience. The content should be tailored to the specifed severity level for the given audience. The severity level is {severity_level}. If the severity level is low, the content should be less sensitive and more generic. If the severity level is medium, the content should be moderately sensitive and somewhat specific. If the severity level is high, the content should be highly sensitive and very specific.",
        )

        # Generate a suitable header for the document based on the content
        header_response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=f"You are an AI generating a suitable header for the following content: {content_response.text}. The header should be concise and relevant with no logos, or emojis, strictly have it word based.",
        )

        # Generate a suitable file name for the document based on the header and content
        filename_response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=f"You are an AI generating a suitable file name for a document with the following header: {header_response.text} and the following content: {content_response.text}. The file name should be concise and relevant with no logos, or emojis, strictly have it word based. Make sure to add the .docx extension at the end of the file name.",
        )

        # Generates a targeted Department based on the content
        department_response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=f"You are an enterprise document classification assistant. Your task is to analyze the content of the document and determine its primary target department from the provided list. Rules: Choose ONLY one department from the list. Base your decision on the document's intent, terminology, and audience. If the document applies to multiple departments, choose the most relevant primary audience. Target Departments: HR, IT, Compliance, Finance, Engineering, Accounting, Audit, Executive, Sales, Marketing. The content of the document is as follows: {content_response.text}",
        )

        return content_response.text, header_response.text, filename_response.text, department_response.text
#--------End Content Creation--------------



-- image_create.py
# Created with the help of Gemini AI 2.5 Flash
from PIL import Image
'''
Inputs:
- token_id (which will be the filename of the image)

Outputs:
- A 1x1 pixel transparent PNG image with the filename of the token_id is saved to a temp directory.
Note: As this script is ran on IIS it will have to be saved temporarily and then moved to the Kali Box appropriately. How this is handled is TBD.
'''


def create_transparent_pixel_image(filename):
    """
    Creates a 1x1 pixel transparent PNG image using the Pillow library.
    Args:
        filename (str): The name of the file to save the image to.
    """
    # 1. Define image dimensions and mode (RGBA for transparency)
    width, height = 1, 1
    img = Image.new('RGBA', (width, height))

    # 2. Define the pixel data: (R, G, B, A)
    # R=0, G=0, B=0 (Black), A=0 (Fully Transparent)
    transparent_pixel = (0, 0, 0, 0)

    # 3. Set the single pixel's color
    img.putpixel((0, 0), transparent_pixel)

    # 4. Save the image with the filename of the canary token ID
    img.save(filename, "PNG")

if __name__ == "__main__":
    # This needs to define the filepath of image on the Kali Box
    create_transparent_pixel_image("canary_token.png")



-- pdf_creation.py

from fpdf import FPDF
import pikepdf
'''
Inputs:
- content (the content to be added to the document)
- header (the header for the document)
- filename (the name of the file to be created)
Outputs:
- A PDF with the content ready for preview. Again need to define folder structure for this still.
'''

# Creating PDF file
def preview_pdf(content, header, filename):
    pdf = FPDF()
    pdf.set_margins(left=15, top=20, right=15)
    pdf.add_page()
    pdf.set_font("Arial", size = 20)

    pdf.cell(0, 10, txt=header, ln=True)
    pdf.set_font("Arial", size = 12)
    pdf.multi_cell(0, 10, txt=content)

    pdf.save(filename)

